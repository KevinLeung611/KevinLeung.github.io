<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring依赖注入实现原理]]></title>
    <url>%2F2019%2F03%2F01%2FSpring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[实现猜想Spring提供@Autowired注解实现依赖注入，当我们想注入一个对象的时候，在成员属性，构造器和方法前加上@Autowired注解，@Autowired默认是按照类型进行注入的，当出现依赖冲突的时候，我们可以使用@Qualifier注解执行bean的名称进行注入。Spring要想实现这个功能，在定义bean的类上搜索有@Autowired注解的成员属性，构造器和方法，然后再从beanFactory中找出合适的bean注入。这是基本的思路，下面我将采用自顶向下的思路来对Spring依赖注入的源码进行剖析。 AbstractBeanFactory在这个类中定义了获取Bean的方法 /** * Return an instance, which may be shared or independent, of the specified bean. * @param name the name of the bean to retrieve * @param requiredType the required type of the bean to retrieve * @param args arguments to use when creating a bean instance using explicit arguments * (only applied when creating a new instance as opposed to retrieving an existing one) * @return an instance of the bean * @throws BeansException if the bean could not be created */ public &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object... args) throws BeansException { return doGetBean(name, requiredType, args, false); } 当Spring调用getBean方法的时候，也就是调用AbstractBeanFactory中的doCreateBean()方法，Spring既然设置Bean默认的生命周期是Singleton，那么，Spring这里先从Singleton的缓存中取出Bean的实例赋值给sharedInstance，如果是singleton固然能从singleton中的缓存中取出相应的实例，若不能，则说明该实例不是一个Singleton或者还没有实例化。 // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) { if (logger.isDebugEnabled()) { if (isSingletonCurrentlyInCreation(beanName)) { logger.debug(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;); } else { logger.debug(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;); } } bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); } 然后使用mbd判断sharedInstance是否是Singleton。mbd表示RootBeanDefinition，用于描述Bean的一些属性，包括这个Bean是否是单例，管理的注入成员，管理的初始化方法和销毁方法，具体的各位读者可以到RootBeanDefinition看看，这里就不讲述了。如果该Bean是一个Singleton，就执行createBean()方法。 / Create bean instance. if (mbd.isSingleton()) { sharedInstance = getSingleton(beanName, () -&gt; { try { return createBean(beanName, mbd, args); } catch (BeansException ex) { // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; } }); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); } 在createBean中有调用了doCreateBean()方法，但是这个doCreateBean()方法是AbstractAutowireCapableBeanFactory的doCreateBean()方法。 try { Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) { logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;); } return beanInstance; } catch (BeanCreationException ex) { // A previously detected exception with proper bean creation context already... throw ex; } catch (ImplicitlyAppearedSingletonException ex) { // An IllegalStateException to be communicated up to DefaultSingletonBeanRegistry... throw ex; } catch (Throwable ex) { throw new BeanCreationException( mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex); } 在doCreateBean的时候会有一个合并BeanDefinition的过程 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); 我们再来看看这个方法的实现，我们发现这个会获取BeanPostProcessors，Spring和我们定义的BeanPostProcessor都会存放在AbstractBeanFactory中，这里获取BeanPostProcessor的集合，只要这个BeanPostprocessor是MergedBeanDefinitionPostProcessor，则执行postProcessMergedBeanDefinition()方法，我们继续最终，发现AbstractAnnotationBeanPostProcessor中定义的postProcessMergedBeanDefinition() /** * Apply MergedBeanDefinitionPostProcessors to the specified bean definition, * invoking their {@code postProcessMergedBeanDefinition} methods. * @param mbd the merged bean definition for the bean * @param beanType the actual type of the managed bean instance * @param beanName the name of the bean * @see MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition */ protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName) { for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof MergedBeanDefinitionPostProcessor) { MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp; bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName); } } } AutowiredAnnotationBeanPostProcessor这个类在org.springframework.beans.factory.annotation下，它是实现@Autowired注解的处理器，先来看一下这个类的定义 public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware 往上溯源我们可以知道，其实AutowiredAnnoationBeanProcessor就是一个BeanPostProcessor，也就意味着，在一个bean被初始化之前和初始化之后是可以做某些操作的。上面提到，Spring在createBean的时候会合并BeanDefinition，在这个时候调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition()方法，关于AutowiredAnnotationBeanPostProcessor中定义的postProcessMergedBeanDefinition()方法如下： @Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) { InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); } 其中的findAutowiringMetadata()就是查找该类中被@Autowired或者@Value修饰的成员，包括成员属性，构造器和方法(@Value不能作用与构造器)，将找到的成员属性或者方法封装在InjectionMetadata的injectedElements中。具体怎么查找并封装的，同学们可以继续追踪下去，这里就不深究了。 AbstractAutowireCapableBeanFactory我们再回到合并BeanDefinition的地方，合并完BeanDefinition之后，也就意味着该类中被@Autowired和@Value注解的成员属性和成员方法已经找到了，但是Spring并没有立即执行注入。往后看，发现： populateBean(beanName, mbd, instanceWrapper); 该方法用于填充Bean，包括依赖注入 for (BeanPostProcessor bp : getBeanPostProcessors()) { if (bp instanceof InstantiationAwareBeanPostProcessor) { InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) { return; } } } 我们可以看到，从AbstractBeanFactory中获取BeanPostProcessor集合，找出InstantiationAwareBeanPostProcessor，调用postProcessPropertyValues()方法，我们来看AutowiredAnnotationBeanPostProcessor的实现 @Override public PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException { InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs); try { metadata.inject(bean, beanName, pvs); } catch (BeanCreationException ex) { throw ex; } catch (Throwable ex) { throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, ex); } return pvs; } 先找出类中被@Autowired或@Value修饰的成员属性和成员方法，如果之前执行了合并BeanDefinition的操作，那么这里获取成员属性和成员方法只需要从缓存中取即可，关键是metadata.inject()方法，使用该方法最终完成依赖注入。 总结同学们看到上面的分析过程可能会有点晕，下面我用简单的方式来总结Spring依赖注入的实现过程。 Spring在实例化Bean的时候会进行合并BeanDefinition的过程，在这个过程中，会查找Bean和该Bean的父类中被@Autowired注解修饰的成员属性和方法，将其添加至AutowiredAnnotationBeanPostProcessor中的缓存中，并封装在InjectionMetaData，这样就完成了预备动作，接下来populateBean也就是填充Bean的时候，通过postProcessorPropertyValues方法将该Bean的依赖注入其中，通过InjectionMetaData的inject()方法就完成注入了。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署出现不必要告警的前因后果]]></title>
    <url>%2F2018%2F10%2F27%2F%E9%83%A8%E7%BD%B2%E5%87%BA%E7%8E%B0%E4%B8%8D%E5%BF%85%E8%A6%81%E5%91%8A%E8%AD%A6%E7%9A%84%E5%89%8D%E5%9B%A0%E5%90%8E%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[很多大公司都是可以利用自己的中间件监控自己应用的性能情况，异常记录和业务成功率等等，如果出现超出预想的监控值，可以通过手机短信，或是其他途径，例如钉钉，给出告警。 现在的问题是，在业务进行迭代的过程里，需要对应用进行重新部署，在重新部署的过程中，容易导致应用不可用，当然，系统的可用性不可能在应用部署的时候被搞垮，在线上机器部署的时候是分批部署的，即使一批机器在部署，其他批次的机器也能提供服务。在阿里工作过的同学都知道，阿里内部的环境复杂性，为了保障线上稳定，需要对多个环境进行验证，一般来说有这几种，日常，预发，灰度，正式。无关紧要的我就不扯了，我们监控的一般是真实环境，而不是测试环境，在这几种环境中，灰度环境和正式环境就是真实的环境，只是灰度环境的机器比较少，因此，即使是分批部署保证可用性，但在灰度机器比较少的情况下，跟正式环境相比，如果其中有一台机器出问题，业务成功率会比正式环境低不少，因此很容易导致告警。 那么这种告警有必要吗？这个跟系统应用有关，具体问题具体分析，因为我们的应用用到了阿里内部的DTS（分布式任务调度系统），DTS客户端启动之后会每隔一段时间进行一次任务调度，那么这里就容易出问题了，如果应用在部署的时候，进行任务调度会怎么样，在部署的时候一些被用到的bean还没有被加载，这个时候就会报错，导致成功率大大减低，从而会造成不必要的告警。 出现这个问题的原因其实在于DTS客户端的启动时机比较靠前，在别的bean还没有加载完成时就已经启动了，解决这个问题的关键在于让DTS客户端的启动往后靠。首先看看DTS客户端这个bean的配置，原先这个bean使用了初始化方法，即在加载这个bean之后立即调用初始化方法，监听相应的端口，往DTS服务端发送心跳检测，表示我这台机器已经可以进行任务调度了，DTS服务端收到之后，就可以往这台机器进行任务调度了。 经过分析之后，很明显，我们需要关注两个时间点，一个是在部署的时候，Spring容器销毁时，还有Spring容器加载bean完成后，在这两个时间点要保证两个事情，一个是在Spring容器销毁的时候，DTS客户端是第一个被销毁的，一个是在Spring容器加载bean完成后，DTS客户端再启动。 Spring提供以上两种Event，分别是ContextRefreshedEvent, ContextClosedEvent，ContextRefreshedEvent会在全部bean加载完成后触发，ContextClosedEvent会在容器内的bean销毁前触发。具体实现思路可以参考如下： public class FirstBean { public void init() { System.out.println(&quot;FirstBean initializing&quot;); } public void destroy() { System.out.println(&quot;FirstBean destroying&quot;); } } public class SecondBean { public void init() { System.out.println(&quot;SecondBean initializing&quot;); } public void destroy() { System.out.println(&quot;SecondBean destroying&quot;); } } @Component public class SpringApplicationLoadedListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; { @Override public void onApplicationEvent(ContextRefreshedEvent event) { ApplicationContext applicationContext = event.getApplicationContext(); if (applicationContext.getParent() == null) { System.out.println(&quot;ApplicationContext loaded&quot;); } } } @Component public class SpringApplicationClosingListener implements ApplicationListener&lt;ContextClosedEvent&gt; { @Override public void onApplicationEvent(ContextClosedEvent event) { ApplicationContext applicationContext = event.getApplicationContext(); if (applicationContext.getParent() == null) { System.out.println(&quot;ApplicationContext closing&quot;); } } }]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS6安装mysql5.7]]></title>
    <url>%2F2018%2F10%2F14%2FCentOS6-%E5%AE%89%E8%A3%85-mysql5-7%2F</url>
    <content type="text"><![CDATA[如何在CentOS6上安装mysql5.7? Step1: 检测系统是否自带安装mysql yum list installed | grep mysql Step2: 删除系统自带的mysql及其依赖 yum -y remove mysql-* Step3: 给CentOS添加rpm源，并且选择较新的源 wget dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm yum localinstall mysql-community-release-el6-5.noarch.rpm yum repolist all | grep mysql yum-config-manager –disable mysql55-community yum-config-manager –disable mysql56-community yum-config-manager –enable mysql57-community-dmr yum repolist enabled | grep mysql Step4:安装mysql 服务器 yum install mysql-community-server Step5: 启动mysql service mysqld start Step6: 查看mysql是否自启动,并且设置开启自启动 chkconfig –list | grep mysqld chkconfig mysqld on Step7: mysql安全设置 mysql_secure_installation Step8：mysql安全设置获取root默认密码 grep “temporary password” /var/log/mysqld.log]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在阿里实习的第四个月]]></title>
    <url>%2F2018%2F10%2F02%2F%E5%9C%A8%E9%98%BF%E9%87%8C%E5%AE%9E%E4%B9%A0%E7%9A%84%E7%AC%AC%E5%9B%9B%E4%B8%AA%E6%9C%88%2F</url>
    <content type="text"><![CDATA[眨眼之间已经在阿里实习了四个月了，在这一段时间里，真的是百感交集，来阿里前的憧憬，刚来阿里的兴奋，紧接着失落，气馁，自己不断地端正心态。 介绍一下我来阿里背景，觉得自己还是挺幸运的。跟我同一届的一个同学，她在脉脉上面认识了一位阿里的员工，这位员工希望她在学校看能不能帮他推人过来，不错，我的这位同学找了我，本来我也没抱多大希望，但是怎么说也是阿里，一直梦寐以求想进的公司，心想试一下吧。经过了四轮面试，最终通过了。没想到我真的通过了，当时因为是大三，学校里还有课，但是我已经迫不及待想去这个“Java程序员圣地”了，所以跟老师请了假，怀着既兴奋又紧张的心情启程了。 到了杭州，亲眼看见了阿里巴巴西溪园区，我还没有入职，当时只能在园区外面向里观望，“老子特么终于可以进阿里了！在阿里有那么多技术牛人，一定可以学到很多牛逼的技术！” 我入职的那一天，找到了带我的师兄，师兄带我到工位的时候，心想，“卧槽，怎么这么挤”，当时我们是在一个小小的会议室里办公的，阿里的人很多，工位也很紧张。我随便找了个位置坐下，就开始准备各种环境，在阿里入职的实习生领的是台式机，师兄见我太可怜了，把他以前的项目机给我用，是一台MacBook Air。另外还有一位同事人非常好，我刚来教了我很多，问他问题很耐心的给我解答，而且有时候还主动过来问我什么情况，点个赞。刚在的这一天，我就搞到十点多，其实我也没什么搞的，环境很快就搭好了，只是我看很多同事都没走，我也不好意思走，哈哈。 刚来也没什么需求需要我做，熟悉环境就好了，而且这个时候没有人跟我说我要做什么，我的师兄基本也不管我的，他实在是太忙了，所以刚开始的时候挺迷茫的，不知道干点什么好，看旁边的人个个都忙得不可开交，心里实在惭愧。 一个月之后，学校开始期末考试了，请了半个月假，订了机票回学校，很着急的考完试，然后又飞回来，继续工作。回来之后，我的师兄渐渐地开始把工作交给我了，不过都是一些很简单的需求，这个页面加几个字段，改几个sql，因为业务的复杂性，刚开始我也只能干这些，但是我有一点不好的地方就是，满足于现状，被困在了这个圈子里了，没有走出圈子看全局，什么意思呢。做的需求因为跟部门的主业务关系不大，因而忽略了主业务的学习，现在回过头来看，浪费了很多时间，认为做完需求就好了，等以后做有关主业务的需求再了解主业务吧。在这里诚心地提醒各位，千万不要有这种思想。 在阿里很讲究一个人的成长，阿里的员工需要有沉淀，什么沉淀呢，一种是技术的沉淀，一种是业务的沉淀，但是不能自己在脑子里过一遍自己懂了就认为好了，什么是沉淀，沉淀需要有特定地载体，不管是文章也好，代码也好，需要体现出你自己的思想。我的师兄就经常要我沉淀相关业务的思考，或者技术上的。我个人也觉得这对一个人的成长是很有帮助的。 但是理想终究敌不过现实，现实是，有一大堆需求要你做，而且还是一些既无聊又恶心人的需求，我们部门是一个业务性质特别强的部门，可能我个人比较抵触，所以越干越没意思，甚至一度想要跟师兄说离职，但是我的师兄真的特别难约，想单独约他吃顿饭几乎是不可能的（他实在是太忙了），所以到现在我也没说出口，当然我也一直在纠结，如果约到了我可能就真的跟他说了。毕竟机会难得，错过了可能就没了，而且考虑到我已经大三了，下学期大四就不能走校招，只能走社招，社招的门槛也比较高，所以说还是有很多现实因素的。当然我自己也在不断端正心态，希望自己接受这种现实，我是为了学习技术而进的阿里，现如今，业务都把我搞得焦头烂额，而且对我来说还是没有吸引力的业务。怎么办呢？不顾三七二十一硬上？其实换个角度想，尽管觉得业务很复杂，可能只是方法论出了问题，不能只局限在这种业务上，要知道，不管到了哪，业务可能都是很复杂的，所以我们要学的不仅仅是业务，而是一种学习业务的方法，我们实习是为了什么？为了学习某种特定的业务吗？不是的，实习我认为是探索学习业务的方法。也不是说探索出一种放之四海而皆准的方法，能找到一种能快速熟悉业务的方法就足够了。这样不管去到哪，不用担心之前没搞过这种业务，没有经验，可以谈谈自己是怎么熟悉业务的，有什么方法，面试的时候也能让面试官眼前一亮。 一个刚出来实习的实习生，而且还是在工作强度极高的阿里，确实是很多人都受不了的，但是人要学会在逆境中前进，总有一天你能快乐地工作和快乐地生活，为自己喜欢的事情而奋斗。]]></content>
      <tags>
        <tag>闲记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义类加载器]]></title>
    <url>%2F2018%2F04%2F14%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[类加载机制中的加载阶段那么jvm在什么情况下处于加载阶段呢？ 在《深入理解Java虚拟机》是这样描述的 这一点jvm规范并没有提供强制约束，而是交给jvm自己去实现。但是有一点，加载阶段一定是发生在初始化阶段之前的，执行初始化阶段的时机是明确规定的： 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。 当使用JDK1.7的动态语言支持时，如果一个java.lang.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 也就是说，在以上这五种情况发生的时候，加载阶段在这之前已经完成了，那么也可以粗略地认为以上五种情况发生了类加载。 类与类加载器为了能够更好理解下面即将展开的内容，先来说一说类与类加载器的关系。请看下面代码 Object firstObj = new Object(); Object secondObj = new Object(); System.out.println(firstObj.getClass() == secondObj.getClass()); 相信同学们清楚，上面的输出结果是什么，大家可能会不假思索的认为上面的输出结果是ture。没错，上面的输出结果就是ture，哈哈。但是大家不要觉得这个问题很幼稚，在jvm的规范中定义两个类是否相等不是直接比较这两个类对象的引用是否一致，还要比较加载这两个类的类加载器是否一样。也就是说，如果firstObj是由firstClassLoader加载的，而sencondObj是由secondClassLoader加载的，那么上面的输出结果就是false了。 双亲委派模型从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器是使用C++实现的，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都是由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器负责将存放在&lt;JAVA_HOME&gt;/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中；一种是扩展类加载器(Extension ClassLoader)，这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME&gt;/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库；还有一种是应用程序类加载器(Application ClassLoader)，这个类加载器由sun.misc.Launcher\$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库。一般情况下这是程序中默认的类加载器。 下图展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型(Parents Delegation Moel)。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。 那么回到这段代码 Object firstObj = new Object(); Object secondObj = new Object(); System.out.println(firstObj.getClass() == secondObj.getClass()); 因为加载Object这个类都是交给Bootstraop ClassLoader去完成，因此认为这个两个类是相等的，如果通过自定义类加载器去加载类，同学们可以比较一下两个Class对象是否相等，当然可以不用Object这个类，自己写一个类也行。 双亲委派模型的实现我们来看看ClassLoader中loadClass的实现（jdk1.8） protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } 我们来分析一下ClassLoader中加载类的过程： findLoadedClass()：检查这个类是否已经被加载过，如果被加载过直接把加载过的这个类返回。 parent.loadClass()：如果这个类加载器有父加载器，那么使用父加载器的loadClass()方法，直到Bootstrap ClassLoader。 findBootstrapClassOrNull()：该方法返回由Bootstrap ClassLoader加载的类，如果没有加载完成则返回null。 findClass()：如果父加载器都没有找到该类，那么就会抛出ClassNotFoundException异常。 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } 自定义 类加载器那么我们怎么自己定义类加载器呢？ 一般来说，我们自定义类加载器的时候，需要去继承ClassLoader，重写findClass()方法，为什么我们是重写findClass()而不是loadClass()呢，下面是关于loadClass()方法的描述 Loads the class with the specified binary name. The default implementation of this method searches for classes in the following order: Invoke findLoadedClass(String) to check if the class has already been loaded. Invoke the loadClass method on the parent class loader. If the parent is null the class loader built-in to the virtual machine is used, instead. Invoke the findClass(String) method to find the class. If the class was found using the above steps, and the resolve flag is true, this method will then invoke the resolveClass(Class) method on the resulting Class object. Subclasses of ClassLoader are encouraged to override findClass(String), rather than this method. Unless overridden, this method synchronizes on the result of getClassLoadingLock method during the entire class loading process. 可以知道，在2中调用父加载器加载类，如果没有找到该类再调用findClass(String)方法加载类，那么我们为了实现双亲委派模型，应该重写findClass(String)方法，而调用loadClass(String)方法 下面我将实现一个类加载器加载Person这个类 Person.java public class Person { private String name; private String sex; public Person(){} public Person(String name, String sex) { this.name = name; this.sex = sex; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } } ClassPathClassLoader.java public class ClassPathClassLoader extends ClassLoader { private static final String CLASSPATH = ClassPathClassLoader.class.getResource(&quot;/&quot;).getPath(); public ClassPathClassLoader(){ } @Override public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { byte[] b = getClassBytes(name); if (b == null) { throw new ClassNotFoundException(name); } else { return defineClass(name, b, 0, b.length); } } private byte[] getClassBytes(String name){ final String classFile = resovleClassName(name); byte[] b = null; try { FileInputStream fis = new FileInputStream(classFile); b = new byte[fis.available()]; fis.read(b); fis.close(); return b; } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return b; } private String resovleClassName(String className) { String classNamePath = className.replaceAll(&quot;\\.&quot;, File.separator); return CLASSPATH + classNamePath + &quot;.class&quot;; } } 测试用例 public class MainClass { public static void main(String[] args) { ClassPathClassLoader classPathClassLoader = new ClassPathClassLoader(); try { Class&lt;?&gt; personClass = classPathClassLoader.loadClass(&quot;cn.kevinleung.Person&quot;); Object obj = personClass.newInstance(); System.out.println(obj.getClass().getClassLoader().getClass().getName()); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } } } 测试结果 sun.misc.Launcher\$AppClassLoader 当调用loadClass()方法时，父加载器加载我们需要的类，这里的AppClassLoader能找到我们需要的类，因此使用该加载器，如果不能则调用findClass()方法，也就是我们重写的方法去加载我们需要的类 参考资料 《深入理解Java虚拟机》]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式的四种实现]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言单例模式能保证我们获取类的实例的时候，只能获取唯一的一个实例，这个实例是常驻内存的。 1. 懒汉式public class LazySingleton { private static LazySingleton singleton; private LazySingleton(){} public static synchronized LazySingleton getInstance(){ if (singleton == null) { singleton = new LazySingleton(); } return singleton; } } 懒汉式的特点就是在获取实例的时候才进行实例化，有懒加载的意思。在获取实例的时候使用synchronized关键字是为了保证线程安全。但是在获取实例的方法getInstance()中为了保证线程安全，对整个方法加锁，锁的粒度较大。 2. 饿汉式public class HungerSingleton { private static final HungerSingleton SINGLETON = new HungerSingleton(); private HungerSingleton(){} public static HungerSingleton getInstance(){ return SINGLETON; } } 饿汉式会在类加载的时候进行初始化，这里因为该实例是不可变的，因此不存在线程不安全的问题。但是有个问题要注意到，就是容易占用额外的空间，原因是非需要时就创建了该实例。 3. 双重检测锁public class DoubleCheckSingleton { private static volatile DoubleCheckSingleton singleton; private DoubleCheckSingleton(){} public static DoubleCheckSingleton getInstance(){ if(singleton == null){ synchronized(DoubleCheckSingleton.class){ if(singleton == null){ singleton = new DoubleCheckSingleton(); } } } return singleton; } } 在高并发的情况下，为了保证线程安全，不得不对getInstance()方法加锁，这里使用了双重检测的方式，先检测singleton是否为空，再进行加锁，然后在判断实singleton是否为空，如果为空再实例化。举个例子，有线程A和线程B同时获取DoubleCheckSingleton的实例，有几种情况 如果线程A经过第一层检测之后，对该类的class实例加锁，然后经过第二层检测，随后实例化对象。此时线程B才去进行第一层检测，直接返回该实例。 如果线程A经过第一层检测之后，线程B也经过的第一层检测，线程A对该类的class实例加锁，然后经过第二层检测，实例化对象。线程B因为无法获取锁而阻塞，当线程A退出synchronized代码块之后释放锁，线程B对该类的class实例加锁，经过第二层判断，此时singleton非空，因此退出该代码块返回singleton的实例。 上述的线程A换做线程B，线程B换做线程A，一样的分析过程。 有同学会注意到，singleton是被volatile修饰的，这里为什么要使用volatile修饰呢？网上说是为了防止jvm指令重排序，在线程A中，因为在实例化的过程中是非原子操作，jvm有可能会先将singleton的引用指向内存某地址，但是该地址空间中的初始化过程还没有完成，此时线程B在其他地方使用该实例就会出现异常。但是本人也有疑点，在《深入理解Java虚拟机》一书中提到，synchronized保证了原子性，可见性和防止指令重排序，何来非原子操作，何来指令重排序？本人也写过相关的实验，并没有发现线程不安全的情况。但本人才疏学浅，可能理解有误，希望各位同学指教，可能在某些场景下真的会发生线程不安全的情况。 4. 枚举public enum EnumSingleton { ENUM_SINGLETON; private EnumSingletonClazz enumSingletonClazz; EnumSingleton(){ enumSingletonClazz = new EnumSingletonClazz(); } public EnumSingletonClazz getInstance(){ return enumSingletonClazz; } } 枚举中的每个元素都是public static final的，而且枚举类的构造方法也是私有的，我们在调用枚举实例的时候会枚举元素会被实例化，因为枚举元素是public static final的，因此枚举实例只有一个，在枚举元素实例化的时候我们将我们要实现单例的类也实例化，从而实现单例。在《Effective Java》一书中推荐使用这种方式。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
